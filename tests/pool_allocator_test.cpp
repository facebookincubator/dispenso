/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <dispenso/pool_allocator.h>

#include <deque>

#include <gtest/gtest.h>

TEST(PoolAllocator, SimpleMallocFree) {
  dispenso::PoolAllocator allocator(64, 256, ::malloc, ::free);

  char* buf = allocator.alloc();

  *buf = 'a';

  allocator.dealloc(buf);
}

TEST(PoolAllocator, TrackAllocations) {
  std::map<char*, size_t> allocMap;

  auto allocFunc = [&allocMap](size_t len) -> void* {
    char* ret = reinterpret_cast<char*>(::malloc(len));
    allocMap.emplace(ret, len);
    return ret;
  };

  auto deallocFunc = [&allocMap](void* ptr) {
    EXPECT_EQ(1, allocMap.erase(reinterpret_cast<char*>(ptr)));
    ::free(ptr);
  };

  // Check to make sure that the ptr returned by the allocator below is in one of the buffers
  // generated by allocFunc.  We do this by examining the closest buffer (via lower_bound) in the
  // map, and then verify that that buffer contains ptr.
  auto checkInValidRange = [&allocMap](char* ptr) {
    auto it = allocMap.upper_bound(ptr);
    --it;
    EXPECT_GE(ptr, it->first);
    EXPECT_LT(ptr, it->first + it->second);
    return ptr;
  };

  {
    dispenso::PoolAllocator allocator(64, 256, allocFunc, deallocFunc);

    char* bufs[5];

    bufs[0] = checkInValidRange(allocator.alloc());

    EXPECT_EQ(1, allocMap.size());

    bufs[1] = checkInValidRange(allocator.alloc());

    EXPECT_EQ(1, allocMap.size());

    allocator.dealloc(bufs[0]);

    EXPECT_EQ(1, allocMap.size());

    bufs[0] = checkInValidRange(allocator.alloc());

    EXPECT_EQ(1, allocMap.size());

    bufs[2] = checkInValidRange(allocator.alloc());

    EXPECT_EQ(1, allocMap.size());

    bufs[3] = checkInValidRange(allocator.alloc());

    EXPECT_EQ(1, allocMap.size());

    bufs[4] = checkInValidRange(allocator.alloc());

    EXPECT_EQ(2, allocMap.size());

    allocator.dealloc(bufs[4]);
    EXPECT_LE(2, allocMap.size());
  }

  EXPECT_EQ(allocMap.size(), 0);
}

TEST(PoolAllocator, SimpleThreaded) {
  constexpr size_t kNumThreads = 8;

  dispenso::PoolAllocator allocator(64, 256, ::malloc, ::free);

  std::deque<std::thread> threads;

  for (size_t i = 0; i < kNumThreads; ++i) {
    threads.emplace_back([&allocator, tid = i]() {
      constexpr size_t kNumBufs = 8;
      char* bufs[kNumBufs];

      for (size_t i = 0; i < 1000; ++i) {
        for (size_t j = 0; j < kNumBufs; ++j) {
          bufs[j] = allocator.alloc();
          *bufs[j] = static_cast<char>(tid);
        }
        for (size_t j = 0; j < kNumBufs; ++j) {
          EXPECT_EQ(*bufs[j], tid);
          allocator.dealloc(bufs[j]);
        }
      }
    });
  }

  for (auto& t : threads) {
    t.join();
  }
}

TEST(PoolAllocator, Arena) {
  dispenso::PoolAllocator allocator(64, 256, ::malloc, ::free);

  std::vector<char*> vec(2000);
  for (char*& c : vec) {
    c = allocator.alloc();
    std::fill_n(c, 64, 0x7f);
  }

  for (char* c : vec) {
    EXPECT_TRUE(std::all_of(c, c + 64, [](char v) { return v == 0x7f; }));
  }

  allocator.clear();
  vec.resize(128);
  for (char*& c : vec) {
    c = allocator.alloc();
    std::fill_n(c, 64, 0x22);
  }

  for (char* c : vec) {
    EXPECT_TRUE(std::all_of(c, c + 64, [](char v) { return v == 0x22; }));
  }

  allocator.clear();
  vec.resize(48);
  for (char*& c : vec) {
    c = allocator.alloc();
    std::fill_n(c, 64, 0x11);
  }

  for (char* c : vec) {
    EXPECT_TRUE(std::all_of(c, c + 64, [](char v) { return v == 0x11; }));
  }
}

TEST(NoLockPoolAllocator, SimpleMallocFree) {
  // Test the non-thread-safe version
  dispenso::NoLockPoolAllocator allocator(64, 256, ::malloc, ::free);

  char* buf = allocator.alloc();
  *buf = 'a';
  allocator.dealloc(buf);
}

TEST(NoLockPoolAllocator, MultipleAllocDealloc) {
  dispenso::NoLockPoolAllocator allocator(32, 128, ::malloc, ::free);

  // Allocate several chunks
  std::vector<char*> bufs;
  for (int i = 0; i < 10; ++i) {
    char* buf = allocator.alloc();
    std::fill_n(buf, 32, static_cast<char>(i));
    bufs.push_back(buf);
  }

  // Verify contents
  for (int i = 0; i < 10; ++i) {
    EXPECT_TRUE(
        std::all_of(bufs[static_cast<size_t>(i)], bufs[static_cast<size_t>(i)] + 32, [i](char v) {
          return v == static_cast<char>(i);
        }));
  }

  // Dealloc all
  for (char* buf : bufs) {
    allocator.dealloc(buf);
  }
}

TEST(PoolAllocator, TotalChunkCapacity) {
  size_t allocCount = 0;
  auto allocFunc = [&allocCount](size_t len) -> void* {
    ++allocCount;
    return ::malloc(len);
  };

  dispenso::PoolAllocator allocator(64, 256, allocFunc, ::free);

  // Initially no backing allocations
  EXPECT_EQ(allocator.totalChunkCapacity(), 0u);

  // First alloc triggers a backing allocation
  char* buf1 = allocator.alloc();
  EXPECT_EQ(allocCount, 1u);
  EXPECT_EQ(allocator.totalChunkCapacity(), 4u); // 256 / 64 = 4 chunks

  // Allocate remaining chunks in first slab
  char* buf2 = allocator.alloc();
  char* buf3 = allocator.alloc();
  char* buf4 = allocator.alloc();
  EXPECT_EQ(allocCount, 1u); // Still just 1 backing allocation
  EXPECT_EQ(allocator.totalChunkCapacity(), 4u);

  // Next alloc triggers another backing allocation
  char* buf5 = allocator.alloc();
  EXPECT_EQ(allocCount, 2u);
  EXPECT_EQ(allocator.totalChunkCapacity(), 8u); // 2 slabs * 4 chunks

  allocator.dealloc(buf1);
  allocator.dealloc(buf2);
  allocator.dealloc(buf3);
  allocator.dealloc(buf4);
  allocator.dealloc(buf5);
}

TEST(PoolAllocator, SingleChunkPerSlab) {
  // Edge case: chunkSize equals allocSize, so only 1 chunk per slab
  size_t allocCount = 0;
  auto allocFunc = [&allocCount](size_t len) -> void* {
    ++allocCount;
    return ::malloc(len);
  };

  dispenso::PoolAllocator allocator(128, 128, allocFunc, ::free);

  EXPECT_EQ(allocator.totalChunkCapacity(), 0u);

  char* buf1 = allocator.alloc();
  EXPECT_EQ(allocCount, 1u);
  EXPECT_EQ(allocator.totalChunkCapacity(), 1u);

  char* buf2 = allocator.alloc();
  EXPECT_EQ(allocCount, 2u);
  EXPECT_EQ(allocator.totalChunkCapacity(), 2u);

  allocator.dealloc(buf1);
  allocator.dealloc(buf2);
}

TEST(PoolAllocator, ClearEmptyAllocator) {
  // Edge case: calling clear() when nothing has been allocated
  dispenso::PoolAllocator allocator(64, 256, ::malloc, ::free);

  // Should not crash
  allocator.clear();
  allocator.clear();

  // Can still allocate after clear
  char* buf = allocator.alloc();
  *buf = 'x';
  EXPECT_EQ(*buf, 'x');
  allocator.dealloc(buf);
}

TEST(PoolAllocator, MultipleClearCycles) {
  size_t allocCount = 0;
  size_t deallocCount = 0;

  auto allocFunc = [&allocCount](size_t len) -> void* {
    ++allocCount;
    return ::malloc(len);
  };

  auto deallocFunc = [&deallocCount](void* ptr) {
    ++deallocCount;
    ::free(ptr);
  };

  {
    dispenso::PoolAllocator allocator(64, 256, allocFunc, deallocFunc);

    // First cycle
    std::vector<char*> bufs;
    for (int i = 0; i < 20; ++i) {
      bufs.push_back(allocator.alloc());
    }
    size_t firstCycleAllocs = allocCount;
    EXPECT_GT(firstCycleAllocs, 0u);

    allocator.clear();
    EXPECT_EQ(deallocCount, 0u); // clear() doesn't deallocate

    // Second cycle - should reuse backing allocations
    bufs.clear();
    for (int i = 0; i < 10; ++i) {
      bufs.push_back(allocator.alloc());
    }
    EXPECT_EQ(allocCount, firstCycleAllocs); // No new backing allocations

    allocator.clear();

    // Third cycle
    bufs.clear();
    for (int i = 0; i < 5; ++i) {
      bufs.push_back(allocator.alloc());
    }
    EXPECT_EQ(allocCount, firstCycleAllocs); // Still no new backing allocations
  }

  // Destructor deallocates all backing allocations
  EXPECT_EQ(deallocCount, allocCount);
}

TEST(PoolAllocator, ReuseAfterDealloc) {
  // Verify that deallocated chunks are reused
  dispenso::PoolAllocator allocator(64, 256, ::malloc, ::free);

  char* buf1 = allocator.alloc();
  std::fill_n(buf1, 64, 'A');

  allocator.dealloc(buf1);

  // Next alloc should return the same chunk (LIFO behavior)
  char* buf2 = allocator.alloc();
  EXPECT_EQ(buf1, buf2);

  // Contents may have been overwritten, but that's expected
  allocator.dealloc(buf2);
}
